//
//  TextureManager.m
//  LocoMotives
//
//  Created by Brandon Mantzey on 11/4/08.
//  Copyright 2008 Stratogon. All rights reserved.
//

#import "TextureManager.h"

@interface TextureManager (Private)

-(int) LoadTexturePrivate:(NSString*)fileName
						 :(GLuint)glIndex
						 :(BOOL)alpha;

@end

@implementation TextureManager (Private)

-(int) LoadTexturePrivate:(NSString*)fileName
						 :(GLuint)glIndex
						 :(BOOL)alpha
{
	//  This code works with TGA files only.
	// TODO: Implement the alpha functionality.
	// TODO: Implement the power of 2 checking functionality.
	GLint nWidth, nHeight, nComponents;
	GLenum eFormat;	
	
	glBindTexture(GL_TEXTURE_2D, glIndex);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1); // 4 is actually default! (1 for .tga)

	FILE *pFile;			// File pointer
    TGAHEADER tgaHeader;		// TGA file header
    unsigned long lImageSize;		// Size in bytes of image
    short sDepth;			// Pixel depth;
    GLbyte	*pBits = NULL;          // Pointer to bits
    
    // Default/Failed values
    nWidth = 0;
    nHeight = 0;
    eFormat = GL_BGR_EXT;
    nComponents = GL_RGB8;
    
    // Attempt to open the fil
    pFile = fopen([fileName cString], "rb");
    if(pFile == NULL)
        return ERR_NOT_FOUND;
	
    // Read in header (binary)
    fread(&tgaHeader, 18, 1, pFile); // 18 = sizeof(TGAHEADER)
    	
    // Get width, height, and depth of texture
    nWidth = tgaHeader.width;
    nHeight = tgaHeader.height;
    sDepth = tgaHeader.bits / 8;
    
    // Put some validity checks here. Very simply, I only understand
    // or care about 8, 24, or 32 bit targa's.
    if(tgaHeader.bits != 8 && tgaHeader.bits != 24 && tgaHeader.bits != 32)
        return ERR_UNSUPPORTED_DEPTH;
	
    // Calculate size of image buffer
    lImageSize = tgaHeader.width * tgaHeader.height * sDepth;
    
    // Allocate memory and check for success
    pBits = (GLbyte*)malloc(lImageSize * sizeof(GLbyte));
    if(pBits == NULL)
        return ERR_LOW_MEMORY;
    
    // Read in the bits
    // Check for read error. This should catch RLE or other 
    // weird formats that I don't want to recognize
    if(fread(pBits, lImageSize, 1, pFile) != 1)
	{
        free(pBits);
        return ERR_RLE_FORMAT;
	}
    
    // Set OpenGL format expected
    switch(sDepth)
	{
        case 3:     // Most likely case
            eFormat = GL_BGR_EXT;
            nComponents = GL_RGB8;
            break;
        case 4:
            eFormat = GL_BGRA_EXT;
            nComponents = GL_RGBA8;
            break;
        case 1:
            eFormat = GL_LUMINANCE;
            nComponents = GL_LUMINANCE8;
            break;
	};
	
	// Done with File
    fclose(pFile);
	
	gluBuild2DMipmaps(GL_TEXTURE_2D, nComponents, nWidth, nHeight, eFormat, GL_UNSIGNED_BYTE, pBits);
	
	free(pBits);
	
	// Bug: every texture must have the same of the following.  Lacks flexibility but fine for now.
	// Solution: Pass ints in that represent the third parameter of the following functions.
	//possibly int[4]
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	
	
	TextureObject *newTexture = [[TextureObject alloc] initWithData:nWidth :nHeight :glIndex];
	[TextureObjects setObject:newTexture forKey:fileName];
	[newTexture release];
	
	return ERR_NONE;
	
	
	
	
	// Here is where we alpha out the passed in key.
	// The image data is in the byte* imageData	
	/*
	 if(alpha)
	 {
	 for(int i=0;i<imageSize-4;i+=4)
	 {
	 if( imageData[i+3] != 255 )
	 continue;
	 if(	imageData[i]	==	alphaOutColor[0]*255	&&
	 imageData[i+1]	==	alphaOutColor[1]*255	&&
	 imageData[i+2]	==	alphaOutColor[2]*255	)
	 {
	 imageData[i+3] = 0;
	 }
	 }
	 }
	 */
	/*
	 float wLog = log2(width);
	 wLog = wLog - (int)wLog;
	 float hLog = log2(height);
	 hLog = hLog - (int)wLog;
	 if(!(hLog || wLog))
	 return ERR_NON_POW2;
	 */
	
}	

@end

#pragma mark TextureManager

@implementation TextureManager

@synthesize	section;
@synthesize xScale;
@synthesize yScale;
@synthesize xScalePoint;
@synthesize yScalePoint;
@synthesize xRot;
@synthesize yRot;
@synthesize rotAngle;
@synthesize xPos;
@synthesize yPos;

static TextureManager* sharedSingleton = 0;

+(TextureManager*)getInstance
{
	if(!sharedSingleton)
	{
		sharedSingleton = [[TextureManager alloc] init];
		return sharedSingleton;
	}
	else
	{
		[sharedSingleton retain];
		return sharedSingleton;
	}
}

+(id)alloc
{
	NSAssert(sharedSingleton == nil, @"Attempted to allocate a second instance of a singleton.");
	sharedSingleton = [super alloc];
	return sharedSingleton;
}

-(id)init
{
	self = [super init];
	if(self)
	{
		TextureObjects = [[NSMutableDictionary alloc] init];
		memoryUsed = 0;
		xScale = 1.0f;
		yScale = 1.0f;
		xRot = 0.0f;
		yRot = 0.0f;
		rotAngle = 0.0f;
		xPos = 0.0f;
		yPos = 0.0f;
		color[0] = 1.0f; color[1] = 1.0f; color[2] = 1.0f; color[3] = 1.0f;
		memset(&section, 0, sizeof(section));
	}
	return self;
}

-(int) LoadTexture:(NSString*)fileName
{
	// This will return nil if the texture has not been loaded yet.  So, if it's null here, it's not a problem.
	TextureObject *newTexture = [TextureObjects objectForKey:fileName];
	if(newTexture)
	{
		newTexture.m_nRetCount++;
		return ERR_ALREADY_LOADED;
	}
	GLuint glIndex;
	glGenTextures(1, &glIndex);
	
	int retVal = [self LoadTexturePrivate:fileName :glIndex :NO];
	if(retVal != ERR_NONE)
	{
		glDeleteBuffers(1, &glIndex);
	}
	return retVal;
}
-(int) LoadTexture:(NSString*)fileName
				  :(M3DVector3f)colorKey
{
	TextureObject *newTexture = [TextureObjects objectForKey:fileName];
	if(newTexture)
	{
		newTexture.m_nRetCount++;
		return ERR_ALREADY_LOADED;
	}
	GLuint glIndex;
	glGenTextures(1, &glIndex);
	
	[self SetAlphaColor:colorKey];	
	int retVal = [self LoadTexturePrivate:fileName :glIndex :YES];
	if(retVal != ERR_NONE)
	{
		glDeleteBuffers(1, &glIndex);
	}
	return retVal;
}

-(GLuint) GetTexID:(NSString*)texKey
{
	TextureObject* texObject = [TextureObjects objectForKey:texKey];
	if(texObject)
		return texObject.m_glIndex;
	return 0;
}

-(BOOL) ReleaseTexture:(NSString*)iden
{
	TextureObject *oldTexture = [TextureObjects objectForKey:iden];
	if(!oldTexture)
		return NO;
	
	memoryUsed -= oldTexture.m_nHeight*4*oldTexture.m_nWidth;
	oldTexture.m_nRetCount--;
	
	if(oldTexture.m_nRetCount <= 0)
	{
		[TextureObjects removeObjectForKey:iden];
		return YES;
	}
	else 
		return NO;
}
-(size_t) GetTextureWidth:(NSString*)iden
{
	TextureObject *temp = [TextureObjects objectForKey:iden];
	return temp.m_nWidth;
}
-(size_t) GetTextureHeight:(NSString*)iden
{
	TextureObject* temp = [TextureObjects objectForKey:iden];
	return temp.m_nHeight;
}
-(void) SetColor:(M3DVector4f)newColor
{
	memcpy(color, newColor, sizeof(M3DVector4f));
}
-(void) SetAlphaColor:(M3DVector3f)alphaOut
{
	memcpy(alphaOutColor, alphaOut, sizeof(M3DVector3f));
}

-(void)dealloc
{
	[TextureObjects removeAllObjects];
	[TextureObjects dealloc];
	[super dealloc];
}

-(TextureObject*) GetTextureObject:(NSString*)iden
{
	return [TextureObjects objectForKey:iden];
}

-(int) Draw:(NSString*)iden
{
	TextureObject *drawTexture = [TextureObjects objectForKey:iden];
	if(!drawTexture)
		return ERR_NOT_LOADED;
	
	// Determine the verts and tex coords
	// By default, draw the entire texture in its original size at the lower left of the screen
	if( (section.origin.y == 0.0f && section.origin.x == 0.0f && section.size.width == 0.0f && section.size.height == 0.0f) )
	{
		section.size.width = drawTexture.m_nWidth;
		section.size.height = drawTexture.m_nHeight;
	}
	GLfloat verts[8] =
	{
		0.0f,							0.0f,							// lower left
		section.size.width,				0.0f,							// upper left
		0.0f,							section.size.height,			// lower right
		section.size.width,				section.size.height				// upper right
	};
	GLfloat texCoords[8] =
	{
		section.origin.x/(float)drawTexture.m_nWidth, section.origin.y/(float)drawTexture.m_nHeight,
		(section.origin.x + section.size.width)/(float)drawTexture.m_nWidth, section.origin.y/(float)drawTexture.m_nHeight,
		section.origin.x/(float)drawTexture.m_nWidth, (section.origin.y + section.size.height)/(float)drawTexture.m_nHeight,
		(section.origin.x + section.size.width)/(float)drawTexture.m_nWidth, (section.origin.y + section.size.height)/(float)drawTexture.m_nHeight
	};
		
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	
	glPushMatrix();
	{
		//MIKE CAMPBELL CHANGE: old scale location...
		
		// Rotate it
		glTranslatef(xRot, yRot, 0.0f);
		glRotatef(rotAngle, 0.0f, 0.0f, 1.0f);
		glTranslatef(-xRot, -yRot, 0.0f);
		
		// Translate it
		glTranslatef(xPos, yPos, 0.0f);
		
		//MIKE CAMPBELL CHANGE: Moved glscale call here, seemed to cause some issues with older placement...
		// Scale it
		glTranslatef(xScalePoint, yScalePoint, 0.0f);
		glScalef(xScale, yScale, 1.0f);
		glTranslatef(-xScalePoint, -yScalePoint, 0.0f);
		
		glBindBuffer(GL_ARRAY_BUFFER, (int)nil);
		/// Apply transformations!
	//	[transform ApplyActorTransform:NO];
		glColor4f(color[0], color[1], color[2], color[3]);

		glBindTexture(GL_TEXTURE_2D, (drawTexture.m_glIndex));
		glVertexPointer(2, GL_FLOAT, 0, verts);
		glEnableClientState(GL_VERTEX_ARRAY);
		glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
		glEnableClientState(GL_TEXTURE_COORD_ARRAY);	
		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
		glDisableClientState(GL_VERTEX_ARRAY);
		glDisableClientState(GL_TEXTURE_COORD_ARRAY);
		
	} glPopMatrix();	
	
	memset(&section, 0.0, sizeof(section));
	xScale = 1.0f;
	yScale = 1.0f;
	xScalePoint = 0.0f;
	yScalePoint = 0.0f;
	xRot = 0.0f;
	yRot = 0.0f;
	rotAngle = 0.0f;
	xPos = 0.0f;
	yPos = 0.0f;

	return ERR_NONE;
}

@end

#pragma mark TextureObject

@implementation TextureObject

@synthesize m_nWidth;
@synthesize m_nHeight;
@synthesize m_nRetCount;
@synthesize m_glIndex;

-(id)initWithData:(size_t)width :(size_t)height: (GLuint)glIndex
{
	[self init];
	m_nWidth = width;
	m_nHeight = height;
	m_glIndex = glIndex;
	return self;
}
-(id)init
{
	self = [super init];
	if(self)
	{
		m_nRetCount = 1;
		m_nWidth = 0;
		m_nHeight = 0;
		m_glIndex = 0;
	}
	return self;
}

-(void)dealloc
{
	[super dealloc];
}
@end
